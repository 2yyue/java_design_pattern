# Java设计模式

## 一、面向对象设计原则

1. 单一职责原则
   Single Responsibility Principle(SRP) 类的职责要单一，不能将太多的职责放在一个类中。
2. 开闭原则
   Open-Closed Principle(OCP) 软件实体对扩展开放，对修改关闭。即在不修改程序的基础上扩展其功能。
3. 里氏代换原则
   Liskov Substitution Principle(LSP) 程序中，可以接受基类对象的代码块一定可以接受子类对象。
4. 依赖倒转原则
   Dependency Inversion Principle(DIP) 针对抽象层编程，而不要针对实现类编程。
5. 接口隔离原则
   Interface Segregation Principle(ISP)使用多个专门的接口来取代一个统一的接口。
6. 合成复用原则
   Composite Reuse Principle(CRP) 尽可能使用组合和聚合关联关系，尽量少甚至不适用继承关系。
7. 迪米特法则
   Law of Demeter(LoD) 一个软件实体对其他实体的引用越少越好。即若两个类不必直接通信，那么这两个类就不应当发生直接的相互作用，而是通过引入第三者发生间接交互。

## 二、设计模式的分类

1. 根据目的分为创建型、结构型和行为型三种
2. 根据设计模式应用范围分为类模式和对象模式

|  范围\目的   |               创建型模式                |                              结构型模式                              |                                       行为型模式                                       |
|:--------:|:----------------------------------:|:---------------------------------------------------------------:|:---------------------------------------------------------------------------------:|
| **
类模式**  |               工厂方法模式               |                            (类)适配器模式                             |                                 解释器模式<br/>模板方法模式                                  |
| **
对象模式** | 抽象工厂模式<br/>建造者模式<br/>原型模式<br/>单例模式 | (对象)适配器模式<br/>桥接模式<br/>组合模式<br/>装饰模式<br/>外观模式<br/>享元模式<br/>代理模式 | 职责链模式<br/>命令模式<br/>迭代模式<br/>中介者模式<br/>备忘录模式<br/>观察者模式<br/>状态模式<br/>策略模式<br/>访问者模式 |

<table>
<tr>
<th>模式类型</th>
<th>模式名称</th>
<th>模式说明</th>
</tr>
<tr>
<td rowspan="6">创建型模式<br/> Creational Patterns</td>
 <tr>
    <td>抽象工厂模式<br/>Abstract Factory</td>
    <td>提供了一个创建一系列相关或互相依赖对象的接口，而无须指定具体实现</td>
  </tr>
<tr>
    <td>建造者模式<br/>Builder</td>
    <td>将一个复杂对象的构建和表示分离，使得同样构建过程可以创建不同的表示</td>
  </tr>
  <tr>
    <td>工厂方法模式<br/>Factory Method</td>
    <td>将类的实例化操作延迟到子类中进行，即由子类决定实例化哪种类</td>
  </tr>
  <tr>
    <td>原型模式<br/>Prototype</td>
    <td>通过给定原型对象来指明所要创建的对象的类型，然后通过复制这个原型对象的办法创建出更多同类型的对象</td>
  </tr>
  <tr>
    <td>单例模式<br/>Singleton</td>
    <td>确保在系统中某一个类只有一个实例，而且自行实例化向整个系统提供这个实例</td>
  </tr>
<tr>
<td rowspan="8">结构型模式<br/> Structural Patterns</td>
 <tr>
    <td>适配器模式<br/>Adapter</td>
    <td>将一个接口转换成用户期待的另一个接口，从而使接口不兼容的那些类可以一起工作</td>
  </tr>
<tr>
    <td>桥接模式<br/>Bridge</td>
    <td>将抽象部分与他的实现分离，使二者可以独立变化</td>
  </tr>
  <tr>
    <td>组合模式<br/>Composite</td>
    <td>通过组合多个对象形成树形结构以表示“整体-部分”的结构层次，对单个对象(即叶子对象)和组合对象(即容器对象)的使用具有一致性</td>
  </tr>
  <tr>
    <td>装饰模式<br/>Decorator</td>
    <td>动态地为一个对象增加额外的职责</td>
  </tr>
  <tr>
    <td>外观模式<br/>Facade</td>
    <td>为复杂子系统提供一个一样的接口</td>
  </tr>
<tr><td>享元模式<br/>Flyweight</td>
<td>通过运用共享技术有效地支持大量细粒度对象的复用</td></tr>
<tr><td>代理模式<br/>Proxy</td>
<td>给某一对象提供一个代理，并由代理对象控制对原对象的引用</td></tr>
<tr>
<td rowspan="12">行为型模式<br/> Behavioral Patterns</td>
 <tr>
    <td>职责链模式<br/>Chain of Responsibility</td>
    <td>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直至有对象处理它为止</td>
  </tr>
<tr>
    <td>命令模式<br/>Command</td>
    <td>将一个请求封装为一个对象，从而使得请求调用者和请求接收者解耦</td>
  </tr>
  <tr>
    <td>解释器模式<br/>Interpreter</td>
    <td>描述如何为语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子</td>
  </tr>
  <tr>
    <td>迭代器模式<br/>Iterator</td>
    <td>提供一个方法来访问聚合对象，而不暴露这个对象的内部表示</td>
  </tr>
  <tr>
    <td>中介者模式<br/>Mediator</td>
    <td>通过一个中介对象来封装一系列的对象交互，使得各对象无需显式相互引用，从而使耦合松散，而且可以独立地改变他们之间的交互</td>
  </tr>
<tr>
    <td>备忘录模式<br/>Memento</td>
    <td>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象外保存这个状态，这样可以在以后回档该备份</td>
  </tr>
<tr>
    <td>观察者模式<br/>Observer</td>
    <td>定义了对象间的一种一对多依赖关系，使得当一个对象状态发生改变时，其相关依赖对象都能得到通知并自动更新</td>
  </tr>
<tr>
    <td>状态模式<br/>State</td>
    <td>允许一个对象在其内部状态改变时改变它的行为</td>
  </tr>
<tr>
    <td>策略模式<br/>Strategy</td>
    <td>定义一系列算法，并将每一个算法封装在一个类中，并让他们可以相互替换，策略模式让算法独立与使用它的用户而变化</td>
  </tr>
<tr>
    <td>模板方法模式<br/>Template Method</td>
    <td>定义一个操作中算法的骨架，而将一些步骤延迟到子类中</td>
  </tr>
<tr>
    <td>访问者模式<br/>Visitor</td>
    <td>表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td>
  </tr>
</table>

## 三、设计模式

> 1. 创建型模式

1. 简单工厂模式
   简单工厂模式Simple Factory Pattern又称为静态工厂方法模式Static Factory Method Pattern，属于类创建型模式。
2. 工厂方法模式
   工厂方法模式Factory Method Pattern又称为工厂模式，也叫虚拟构造器Virtual Constructor模式或者多态工厂Polymorphic Factory模式，属于类创建型模式。
3. 抽象工厂模式
4. 建造者模式
5. 原型模式
6. 单例模式
7. 适配器模式
8. 桥接模式
9. 组合模式
10. 装饰模式
11. 外观模式
12. 享元模式
13. 代理模式
14. 职责链模式
15. 命令模式
16. 解释器模式
17. 迭代器模式
18. 中介者模式
19. 备忘录模式
20. 观察者模式
21. 状态模式
22. 策略模式
23. 模板方法模式
24. 访问者模式
